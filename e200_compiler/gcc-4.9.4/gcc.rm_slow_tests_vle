diff --git a/gcc/testsuite/gfortran.dg/matmul_6.f90 b/gcc/testsuite/gfortran.dg/matmul_6.f90
deleted file mode 100644
index 737c5c4..0000000
--- a/gcc/testsuite/gfortran.dg/matmul_6.f90
+++ /dev/null
@@ -1,66 +0,0 @@
-! { dg-do run }
-! PR 34566 - logical matmul used to give the wrong result.
-! We check this by running through every permutation in
-! multiplying two 3*3 matrices, and all permutations of multiplying
-! a 3-vector and a 3*3 matrices  and checking against equivalence
-! with integer matrix multiply.
-program main
-  implicit none
-  integer, parameter :: ki=4
-  integer, parameter :: dimen=3
-  integer :: i, j, k
-  real, dimension(dimen,dimen) :: r1, r2
-  integer, dimension(dimen,dimen) :: m1, m2
-  logical(kind=ki), dimension(dimen,dimen) :: l1, l2
-  logical(kind=ki), dimension(dimen*dimen) :: laux
-  logical(kind=ki), dimension(dimen) :: lv
-  integer, dimension(dimen) :: iv
-
-  do i=0,2**(dimen*dimen)-1
-     forall (k=1:dimen*dimen)
-        laux(k) = btest(i, k-1)
-     end forall
-     l1 = reshape(laux,shape(l1))
-     m1 = ltoi(l1)
-
-     ! Check matrix*matrix multiply
-     do j=0,2**(dimen*dimen)-1
-        forall (k=1:dimen*dimen)
-           laux(k) = btest(i, k-1)
-        end forall
-        l2 = reshape(laux,shape(l2))
-        m2 = ltoi(l2)
-        if (any(matmul(l1,l2) .neqv. (matmul(m1,m2) /= 0))) then
-          call abort
-        end if
-     end do
-
-     ! Check vector*matrix and matrix*vector multiply.
-     do j=0,2**dimen-1
-        forall (k=1:dimen)
-           lv(k) = btest(j, k-1)
-        end forall
-        iv = ltoi(lv)
-        if (any(matmul(lv,l1) .neqv. (matmul(iv,m1) /=0))) then
-          call abort
-        end if
-        if (any(matmul(l1,lv) .neqv. (matmul(m1,iv) /= 0))) then
-          call abort
-        end if
-     end do
-  end do
-
-contains
-  elemental function ltoi(v)
-    implicit none
-    integer :: ltoi
-    real :: rtoi
-    logical(kind=4), intent(in) :: v
-    if (v) then
-       ltoi = 1
-    else
-       ltoi = 0
-    end if
-  end function ltoi
-
-end program main
diff -ruN gcc-4.9.4-original/gcc/testsuite/gcc.dg/graphite/pr46185.c gcc-4.9.4/gcc/testsuite/gcc.dg/graphite/pr46185.c
--- gcc-4.9.4-original/gcc/testsuite/gcc.dg/graphite/pr46185.c	2017-11-29 15:38:40.648419535 -0600
+++ gcc-4.9.4/gcc/testsuite/gcc.dg/graphite/pr46185.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,46 +0,0 @@
-/* { dg-do run } */
-/* { dg-options "-O2 -floop-interchange -ffast-math -fno-ipa-cp" } */
-
-#define DEBUG 0
-#if DEBUG
-#include <stdio.h>
-#endif
-
-double u[1782225];
-
-static int __attribute__((noinline))
-foo (int N, int *res)
-{
-  int i, j;
-  double sum = 0;
-  for (i = 0; i < N; i++)
-    for (j = 0; j < N; j++)
-      sum = sum + u[i + 1335 * j];
-
-  for (i = 0; i < N; i++)
-    u[1336 * i] *= 2;
-
-  *res = sum + N + u[1336 * 2] + u[1336];
-}
-
-extern void abort ();
-
-int
-main (void)
-{
-  int i, j, res;
-
-  for (i = 0; i < 1782225; i++)
-    u[i] = 2;
-
-  foo (1335, &res);
-
-#if DEBUG
-  fprintf (stderr, "res = %d \n", res);
-#endif
-
-  if (res != 3565793)
-    abort ();
-
-  return 0;
-}
diff -ruN gcc-4.9.4-original/gcc/testsuite/gcc.dg/torture/vec-cvt-1.c gcc-4.9.4/gcc/testsuite/gcc.dg/torture/vec-cvt-1.c
--- gcc-4.9.4-original/gcc/testsuite/gcc.dg/torture/vec-cvt-1.c	2017-11-29 15:38:40.626419536 -0600
+++ gcc-4.9.4/gcc/testsuite/gcc.dg/torture/vec-cvt-1.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,213 +0,0 @@
-/* { dg-do run } */
-/* This test is too big for small targets.  */
-/* { dg-require-effective-target size32plus } */
-
-#include <stdlib.h>
-
-#define N 1024
-signed char sc[N];
-short ss[N];
-int si[N];
-long long sl[N];
-unsigned char uc[N];
-unsigned short us[N];
-unsigned int ui[N];
-unsigned long long ul[N];
-float f[N];
-double d[N];
-
-#define FN1(from, to) \
-__attribute__((noinline, noclone)) void		\
-from##2##to (void)				\
-{						\
-  int i;					\
-  for (i = 0; i < N; i++)			\
-    to[i] = from[i];				\
-}
-#define FN(intt, fltt) FN1 (intt, fltt) FN1 (fltt, intt)
-
-FN (sc, f)
-FN (ss, f)
-FN (si, f)
-FN (sl, f)
-FN (uc, f)
-FN (us, f)
-FN (ui, f)
-FN (ul, f)
-FN (sc, d)
-FN (ss, d)
-FN (si, d)
-FN (sl, d)
-FN (uc, d)
-FN (us, d)
-FN (ui, d)
-FN (ul, d)
-
-#define FLTTEST(min, max, intt) \
-__attribute__((noinline, noclone)) void					\
-flttointtest##intt (void)						\
-{									\
-  int i;								\
-  volatile float fltmin, fltmax, vf, vf2;				\
-  volatile double dblmin, dblmax, vd, vd2;				\
-  if (min == 0)								\
-    fltmin = 0.0f;							\
-  else									\
-    {									\
-      vf2 = fltmin = min - 1.0f;					\
-      for (vf = 1.0f; (fltmin = vf2 + vf) == vf2; vf = vf * 2.0f)	\
-	;								\
-    }									\
-  vf2 = fltmax = max + 1.0f;						\
-  for (vf = 1.0f; (fltmax = vf2 - vf) == vf2; vf = vf * 2.0f)		\
-    ;									\
-  if (min == 0)								\
-    dblmin = 0.0;							\
-  else									\
-    {									\
-      vd2 = dblmin = min - 1.0;						\
-      for (vd = 1.0; (dblmin = vd2 + vd) == vd2; vd = vd * 2.0)		\
-	;								\
-    }									\
-  vd2 = dblmax = max + 1.0;						\
-  for (vd = 1.0; (dblmax = vd2 - vd) == vd2; vd = vd * 2.0)		\
-    ;									\
-  for (i = 0; i < N; i++)						\
-    {									\
-      asm ("");								\
-      if (i == 0)							\
-	f[i] = fltmin;							\
-      else if (i < N / 4)						\
-	f[i] = fltmin + i + 0.25f;					\
-      else if (i < 3 * N / 4)						\
-	f[i] = (fltmax + fltmin) / 2.0 - N * 8 + 16.0f * i;		\
-      else								\
-	f[i] = fltmax - N + 1 + i;					\
-      if (f[i] < fltmin) f[i] = fltmin;					\
-      if (f[i] > fltmax) f[i] = fltmax;					\
-      if (i == 0)							\
-	d[i] = dblmin;							\
-      else if (i < N / 4)						\
-	d[i] = dblmin + i + 0.25f;					\
-      else if (i < 3 * N / 4)						\
-	d[i] = (dblmax + dblmin) / 2.0 - N * 8 + 16.0f * i;		\
-      else								\
-	d[i] = dblmax - N + 1 + i;					\
-      if (d[i] < dblmin) d[i] = dblmin;					\
-      if (d[i] > dblmax) d[i] = dblmax;					\
-    }									\
-  f2##intt ();								\
-  for (i = 0; i < N; i++)						\
-    if (intt[i] != (__typeof (intt[0])) f[i])				\
-      abort ();								\
-  d2##intt ();								\
-  for (i = 0; i < N; i++)						\
-    if (intt[i] != (__typeof (intt[0])) d[i])				\
-      abort ();								\
-  for (i = 0; i < N; i++)						\
-    {									\
-      unsigned long long r = rand ();					\
-      r = (r << 21) ^ (unsigned) rand ();				\
-      r = (r << 21) ^ (unsigned) rand ();				\
-      asm ("");								\
-      f[i] = (r >> 59) / 32.0f + (__typeof (intt[0])) r;		\
-      if (f[i] < fltmin) f[i] = fltmin;					\
-      if (f[i] > fltmax) f[i] = fltmax;					\
-      d[i] = (r >> 59) / 32.0 + (__typeof (intt[0])) r;			\
-      if (d[i] < dblmin) f[i] = dblmin;					\
-      if (d[i] > dblmax) f[i] = dblmax;					\
-    }									\
-  f2##intt ();								\
-  for (i = 0; i < N; i++)						\
-    if (intt[i] != (__typeof (intt[0])) f[i])				\
-      abort ();								\
-  d2##intt ();								\
-  for (i = 0; i < N; i++)						\
-    if (intt[i] != (__typeof (intt[0])) d[i])				\
-      abort ();								\
-}									\
-									\
-__attribute__((noinline, noclone)) void					\
-inttoflttest##intt (void)						\
-{									\
-  int i;								\
-  volatile float vf;							\
-  volatile double vd;							\
-  for (i = 0; i < N; i++)						\
-    {									\
-      asm ("");								\
-      if (i < N / 4)							\
-	intt[i] = min + i;						\
-      else if (i < 3 * N / 4)						\
-	intt[i] = (max + min) / 2 - N * 8 + 16 * i;			\
-      else								\
-	intt[i] = max - N + 1 + i;					\
-    }									\
-  intt##2f ();								\
-  for (i = 0; i < N; i++)						\
-    {									\
-      vf = intt[i];							\
-      if (f[i] != vf)							\
-	abort ();							\
-    }									\
-  intt##2d ();								\
-  for (i = 0; i < N; i++)						\
-    {									\
-      vd = intt[i];							\
-      if (d[i] != vd)							\
-	abort ();							\
-    }									\
-  for (i = 0; i < N; i++)						\
-    {									\
-      unsigned long long r = rand ();					\
-      r = (r << 21) ^ (unsigned) rand ();				\
-      r = (r << 21) ^ (unsigned) rand ();				\
-      asm ("");								\
-      intt[i] = r;							\
-    }									\
-  intt##2f ();								\
-  for (i = 0; i < N; i++)						\
-    {									\
-      vf = intt[i];							\
-      if (f[i] != vf)							\
-	abort ();							\
-    }									\
-  intt##2d ();								\
-  for (i = 0; i < N; i++)						\
-    {									\
-      vd = intt[i];							\
-      if (d[i] != vd)							\
-	abort ();							\
-    }									\
-}
-
-FLTTEST (- __SCHAR_MAX__ - 1, __SCHAR_MAX__, sc)
-FLTTEST (- __SHRT_MAX__ - 1, __SHRT_MAX__, ss)
-FLTTEST (- __INT_MAX__ - 1, __INT_MAX__, si)
-FLTTEST (- __LONG_LONG_MAX__ - 1LL, __LONG_LONG_MAX__, sl)
-FLTTEST (0, 2U * __SCHAR_MAX__ + 1, uc)
-FLTTEST (0, 2U * __SHRT_MAX__ + 1, us)
-FLTTEST (0, 2U * __INT_MAX__ + 1, ui)
-FLTTEST (0, 2ULL * __LONG_LONG_MAX__ + 1, ul)
-
-int
-main ()
-{
-  flttointtestsc ();
-  flttointtestss ();
-  flttointtestsi ();
-  flttointtestsl ();
-  flttointtestuc ();
-  flttointtestus ();
-  flttointtestui ();
-  flttointtestul ();
-  inttoflttestsc ();
-  inttoflttestss ();
-  inttoflttestsi ();
-  inttoflttestsl ();
-  inttoflttestuc ();
-  inttoflttestus ();
-  inttoflttestui ();
-  inttoflttestul ();
-  return 0;
-}
diff -ruN gcc-4.9.4-original/gcc/testsuite/g++.dg/ext/vla15.C gcc-4.9.4/gcc/testsuite/g++.dg/ext/vla15.C
--- gcc-4.9.4-original/gcc/testsuite/g++.dg/ext/vla15.C	2017-11-29 15:38:41.478419476 -0600
+++ gcc-4.9.4/gcc/testsuite/g++.dg/ext/vla15.C	1969-12-31 18:00:00.000000000 -0600
@@ -1,20 +0,0 @@
-// PR c++/44613
-// { dg-do run }
-// { dg-options "" }
-
-void *volatile p;
-
-int
-main (void)
-{
-  int n = 0;
- lab:;
-  int x[n % 1000 + 1];
-  x[0] = 1;
-  x[n % 1000] = 2;
-  p = x;
-  n++;
-  if (n < 1000000)
-    goto lab;
-  return 0;
-}
diff -ruN gcc-4.9.4-original/gcc/testsuite/g++.dg/template/array15.C gcc-4.9.4/gcc/testsuite/g++.dg/template/array15.C
--- gcc-4.9.4-original/gcc/testsuite/g++.dg/template/array15.C	2017-11-29 15:38:41.605419467 -0600
+++ gcc-4.9.4/gcc/testsuite/g++.dg/template/array15.C	1969-12-31 18:00:00.000000000 -0600
@@ -1,13 +0,0 @@
-// PR c++/28595
-
-template<int> struct A
-{
-  static const int i;
-};
-
-template<int N> struct B
-{
-  char c[A<N>::i], d; // { dg-error "constant" }
-};
-
-B<0> b;
diff -ruN gcc-4.9.4-original/gcc/testsuite/g++.dg/template/array16.C gcc-4.9.4/gcc/testsuite/g++.dg/template/array16.C
--- gcc-4.9.4-original/gcc/testsuite/g++.dg/template/array16.C	2017-11-29 15:38:41.596419468 -0600
+++ gcc-4.9.4/gcc/testsuite/g++.dg/template/array16.C	1969-12-31 18:00:00.000000000 -0600
@@ -1,9 +0,0 @@
-// PR c++/28886
-
-template<typename> struct A;
-
-template<typename T, int N> struct A<T[N]> {};
-
-template<typename T, int N> struct A<const T[N]> {};
-
-A<const int[1]> a;
diff -ruN gcc-4.9.4-original/gcc/testsuite/gfortran.dg/default_format_1.f90 gcc-4.9.4/gcc/testsuite/gfortran.dg/default_format_1.f90
--- gcc-4.9.4-original/gcc/testsuite/gfortran.dg/default_format_1.f90	2017-11-29 15:38:41.104419503 -0600
+++ gcc-4.9.4/gcc/testsuite/gfortran.dg/default_format_1.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,26 +0,0 @@
-! { dg-do run { xfail spu-*-* powerpc-ibm-aix* } }
-! Test XFAILed on Darwin because the system's printf() lacks
-! proper support for denormals.
-!
-! This tests that the default formats for formatted I/O of reals are
-! wide enough and have enough precision, by checking that values can
-! be written and read back.
-!
-include "default_format_1.inc"
-
-program main
-  use test_default_format
-
-  if (test (1.0_4, 0) /= 0) call abort
-  if (test (tiny(0.0_4), 1) /= 0) call abort
-  if (test (-tiny(0.0_4), -1) /= 0) call abort
-  if (test (huge(0.0_4), -1) /= 0) call abort
-  if (test (-huge(0.0_4), 1) /= 0) call abort
-
-  if (test (1.0_8, 0) /= 0) call abort
-  if (test (tiny(0.0_8), 1) /= 0) call abort
-  if (test (-tiny(0.0_8), -1) /= 0) call abort
-  if (test (huge(0.0_8), -1) /= 0) call abort
-  if (test (-huge(0.0_8), 1) /= 0) call abort
-end program main
-!
diff -ruN gcc-4.9.4-original/gcc/testsuite/gfortran.dg/dependency_3.f90 gcc-4.9.4/gcc/testsuite/gfortran.dg/dependency_3.f90
--- gcc-4.9.4-original/gcc/testsuite/gfortran.dg/dependency_3.f90	2017-11-29 15:38:41.150419499 -0600
+++ gcc-4.9.4/gcc/testsuite/gfortran.dg/dependency_3.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,28 +0,0 @@
-! { dg-do run }
-! Tests the fix for PR24519, in which assignments with the same
-! range of an assumed shape array, on the lhs and rhs, would be
-! treated as causing a dependency.
-!
-! Contributed by Paul.Thomas  <pault@gcc.gnu.org>
-!
-  integer, parameter :: n = 100
-  real :: x(n, n), v
-  x = 1
-  v = 0.1
-  call foo (x, v)
-  if (abs(sum (x) -  91.10847) > 1e-3) print *, sum (x)
-contains
-  subroutine foo (b, d)
-    real :: b(:, :)
-    real :: temp(n), c, d
-    integer :: j, k
-    do k = 1, n
-      temp = b(:,k)
-      do j = 1, n
-        c = b(k,j)*d
-        b(:,j) = b(:,j)-temp*c  ! This was the offending assignment.
-        b(k,j) = c
-      end do
-    end do
-  end subroutine foo
-end
diff -ruN gcc-4.9.4-original/gcc/testsuite/gfortran.dg/direct_io_12.f90 gcc-4.9.4/gcc/testsuite/gfortran.dg/direct_io_12.f90
--- gcc-4.9.4-original/gcc/testsuite/gfortran.dg/direct_io_12.f90	2017-11-29 15:38:41.136419500 -0600
+++ gcc-4.9.4/gcc/testsuite/gfortran.dg/direct_io_12.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,33 +0,0 @@
-! { dg-do run }
-! 
-! PR fortran/43551
-!
-! Writes a 672000 byte file with buffering. The writing failed because
-! of a missing lseek.
-
-implicit none
-integer, parameter :: size = 2800 ! << needs to be large enough
-real(8) :: vec1(size,30), dummy(size)
-integer i
-
-CALL RANDOM_NUMBER(vec1)
-
-open(99, file='test.dat', form='unformatted', access='direct', recl=size*8)
-do i = 1, 10
-  write(99,rec=i) vec1(:,i)
-  write(99,rec=i+10) vec1(:,i+10)
-  write(99,rec=i+20) vec1(:,i+20) ! << rec = 30 was written to rec = 21
-end do
-
-do i = 1, 10
-  read(99,rec=i) dummy
-  if (any (dummy /= vec1(:,i))) call abort()
-  read(99,rec=i+10) dummy
-  if (any (dummy /= vec1(:,i+10))) call abort()
-  read(99,rec=i+20) dummy
-  if (any (dummy /= vec1(:,i+20))) call abort() ! << aborted here for rec = 21
-end do
-
-close(99, status='delete')
-end
-
diff -ruN gcc-4.9.4-original/gcc/testsuite/gfortran.dg/fmt_fw_d.f90 gcc-4.9.4/gcc/testsuite/gfortran.dg/fmt_fw_d.f90
--- gcc-4.9.4-original/gcc/testsuite/gfortran.dg/fmt_fw_d.f90	2017-11-29 15:38:41.115419502 -0600
+++ gcc-4.9.4/gcc/testsuite/gfortran.dg/fmt_fw_d.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,131 +0,0 @@
-! { dg-do run }
-! { dg-options "-std=gnu" }
-! PR47567 Wrong output for small absolute values with F editing
-! Test case provided by Thomas Henlich 
-call verify_fmt(1.2)
-call verify_fmt(-0.1)
-call verify_fmt(1e-7)
-call verify_fmt(1e-6)
-call verify_fmt(1e-5)
-call verify_fmt(1e-4)
-call verify_fmt(1e-3)
-call verify_fmt(1e-2)
-call verify_fmt(-1e-7)
-call verify_fmt(-1e-6)
-call verify_fmt(-1e-5)
-call verify_fmt(-1e-4)
-call verify_fmt(-1e-3)
-call verify_fmt(-1e-2)
-call verify_fmt(tiny(0.0))
-call verify_fmt(-tiny(0.0))
-call verify_fmt(0.0)
-call verify_fmt(-0.0)
-call verify_fmt(100.0)
-call verify_fmt(.12345)
-call verify_fmt(1.2345)
-call verify_fmt(12.345)
-call verify_fmt(123.45)
-call verify_fmt(1234.5)
-call verify_fmt(12345.6)
-call verify_fmt(123456.7)
-call verify_fmt(99.999)
-call verify_fmt(-100.0)
-call verify_fmt(-99.999)
-end
-
-! loop through values for w, d
-subroutine verify_fmt(x)
-    real, intent(in) :: x
-    integer :: w, d
-    character(len=80) :: str, str0
-    integer :: len, len0
-    character(len=80) :: fmt_w_d
-    logical :: result, have_num, verify_fmt_w_d
-    
-    do d = 0, 10
-        have_num = .false.
-        do w = 1, 20
-            str = fmt_w_d(x, w, d)
-            len = len_trim(str)
-            
-            result = verify_fmt_w_d(x, str, len, w, d)
-            if (.not. have_num .and. result) then
-                have_num = .true.
-                str0 = fmt_w_d(x, 0, d)
-                len0 = len_trim(str0)
-                if (len /= len0) then
-                    call errormsg(x, str0, len0, 0, d, "selected width is wrong")
-                else
-                    if (str(:len) /= str0(:len0)) call errormsg(x, str0, len0, 0, d, "output is wrong")
-                end if
-            end if
-        end do
-    end do
-
-end subroutine
-
-! checks for standard-compliance, returns .true. if field contains number, .false. on overflow
-function verify_fmt_w_d(x, str, len, w, d)
-    real, intent(in) :: x
-    character(len=80), intent(in) :: str
-    integer, intent(in) :: len
-    integer, intent(in) :: w, d
-    logical :: verify_fmt_w_d
-    integer :: pos
-    character :: decimal_sep = "."
-
-    verify_fmt_w_d = .false.
-    
-    ! check if string is all asterisks
-    pos = verify(str(:len), "*")
-    if (pos == 0) return
-    
-    ! check if string contains a digit
-    pos = scan(str(:len), "0123456789")
-    if (pos == 0) call errormsg(x, str, len, w, d, "no digits")
-
-    ! contains decimal separator?
-    pos = index(str(:len), decimal_sep)
-    if (pos == 0) call errormsg(x, str, len, w, d, "no decimal separator")
-    
-    ! negative and starts with minus?
-    if (sign(1., x) < 0.) then
-        pos = verify(str, " ")
-        if (pos == 0) call errormsg(x, str, len, w, d, "only spaces")
-        if (str(pos:pos) /= "-") call errormsg(x, str, len, w, d, "no minus sign")
-    end if
-    
-    verify_fmt_w_d = .true.
-end function
-
-function fmt_w_d(x, w, d)
-    real, intent(in) :: x
-    integer, intent(in) :: w, d
-    character(len=*) :: fmt_w_d
-    character(len=10) :: fmt, make_fmt
-    
-    fmt = make_fmt(w, d)
-    write (fmt_w_d, fmt) x
-end function
-
-function make_fmt(w, d)
-    integer, intent(in) :: w, d
-    character(len=10) :: make_fmt
-    
-    write (make_fmt,'("(f",i0,".",i0,")")') w, d
-end function
-
-subroutine errormsg(x, str, len, w, d, reason)
-    real, intent(in) :: x
-    character(len=80), intent(in) :: str
-    integer, intent(in) :: len, w, d
-    character(len=*), intent(in) :: reason
-    integer :: fmt_len
-    character(len=10) :: fmt, make_fmt
-    
-    fmt = make_fmt(w, d)
-    fmt_len = len_trim(fmt)
-    
-    !print *, "print '", fmt(:fmt_len), "', ", x, " ! => ", str(:len), ": ", reason
-    call abort
-end subroutine
diff -ruN gcc-4.9.4-original/gcc/testsuite/gfortran.dg/realloc_on_assign_15.f90 gcc-4.9.4/gcc/testsuite/gfortran.dg/realloc_on_assign_15.f90
--- gcc-4.9.4-original/gcc/testsuite/gfortran.dg/realloc_on_assign_15.f90	2017-11-29 15:38:41.073419505 -0600
+++ gcc-4.9.4/gcc/testsuite/gfortran.dg/realloc_on_assign_15.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,40 +0,0 @@
-! { dg-do run }
-!
-! PR fortran/53389
-!
-! The program was leaking memory before due to
-! realloc on assignment and nested functions.
-!
-module foo
-  implicit none
-  contains
-
-  function filler(array, val)
-    real, dimension(:), intent(in):: array
-    real, dimension(size(array)):: filler
-    real, intent(in):: val
-
-    filler=val
-
-  end function filler
-end module
-
-program test
-  use foo
-  implicit none
-
-  real, dimension(:), allocatable:: x, y
-  integer, parameter:: N=1000 !*1000
-  integer:: i
-
-!  allocate( x(N) )
-  allocate( y(N) )
-  y=0.0
-
-  do i=1, N
-!    print *,i
-    x=filler(filler(y, real(2*i)), real(i))
-    y=y+x
-  end do
-
-end program test
diff -ruN gcc-4.9.4-original/gcc/testsuite/gfortran.dg/realloc_on_assign_17.f90 gcc-4.9.4/gcc/testsuite/gfortran.dg/realloc_on_assign_17.f90
--- gcc-4.9.4-original/gcc/testsuite/gfortran.dg/realloc_on_assign_17.f90	2017-11-29 15:38:41.038419507 -0600
+++ gcc-4.9.4/gcc/testsuite/gfortran.dg/realloc_on_assign_17.f90	1969-12-31 18:00:00.000000000 -0600
@@ -1,47 +0,0 @@
-! { dg-do run }
-! Test the fix for PR47517
-!
-! Reported by Tobias Burnus  <burnus@gcc.gnu.org>
-! from a testcase by James Van Buskirk
-module mytypes
-   implicit none
-   type label
-      integer, allocatable :: parts(:)
-   end type label
-   type table
-      type(label), allocatable :: headers(:)
-   end type table
-end module mytypes
-
-program allocate_assign
-   use mytypes
-   implicit none
-   integer, parameter :: ik8 = selected_int_kind(18)
-   type(table) x1(2)
-   type(table) x2(3)
-   type(table), allocatable :: x(:)
-   integer i, j, k
-   integer(ik8) s
-   call foo
-   s = 0
-   do k = 1, 10000
-      x = x1
-      s = s+x(2)%headers(2)%parts(2)
-      x = x2
-      s = s+x(2)%headers(2)%parts(2)
-   end do
-   if (s .ne. 40000) call abort
-contains
-!
-! TODO - these assignments lose 1872 bytes on x86_64/FC17
-! This is PR38319
-!
-   subroutine foo
-       x1 = [table([(label([(j,j=1,3)]),i=1,3)]), &
-             table([(label([(j,j=1,4)]),i=1,4)])]
-
-       x2 = [table([(label([(j,j=1,4)]),i=1,4)]), &
-             table([(label([(j,j=1,5)]),i=1,5)]), &
-             table([(label([(j,j=1,6)]),i=1,6)])]
-   end subroutine
-end program allocate_assign
diff -ruN gcc-4.9.4-original/gcc/testsuite/gfortran.dg/typebound_operator_9.f03 gcc-4.9.4/gcc/testsuite/gfortran.dg/typebound_operator_9.f03
--- gcc-4.9.4-original/gcc/testsuite/gfortran.dg/typebound_operator_9.f03	2017-11-29 15:38:41.079419504 -0600
+++ gcc-4.9.4/gcc/testsuite/gfortran.dg/typebound_operator_9.f03	1969-12-31 18:00:00.000000000 -0600
@@ -1,500 +0,0 @@
-! { dg-do run }
-! { dg-add-options ieee }
-! { dg-skip-if "Too big for local store" { spu-*-* } { "*" } { "" } }
-!
-!     Solve a diffusion problem using an object-oriented approach
-!
-!     Author: Arjen Markus (comp.lang.fortran)
-!     This version: pault@gcc.gnu.org
-!
-!     Note:
-!     (i) This could be turned into a more sophisticated program
-!     using the techniques described in the chapter on
-!     mathematical abstractions.
-!     (That would allow the selection of the time integration
-!     method in a transparent way)
-!
-!     (ii) The target procedures for process_p and source_p are
-!     different to the typebound procedures for dynamic types
-!     because the passed argument is not type(base_pde_object).
-!
-!     (iii) Two solutions are calculated, one with the procedure
-!     pointers and the other with typebound procedures. The sums
-!     of the solutions are compared.
-
-!     (iv) The source is a delta function in the middle of the
-!     mesh, whilst the process is quartic in the local value,
-!     when it is positive.
-!
-! base_pde_objects --
-!     Module to define the basic objects
-!
-module base_pde_objects
-  implicit none
-  type, abstract :: base_pde_object
-! No data
-    procedure(process_p), pointer, pass :: process_p
-    procedure(source_p), pointer, pass  :: source_p
-  contains
-    procedure(process), deferred :: process
-    procedure(source), deferred :: source
-    procedure :: initialise
-    procedure :: nabla2
-    procedure :: print
-    procedure(real_times_obj), pass(obj), deferred :: real_times_obj
-    procedure(obj_plus_obj),              deferred :: obj_plus_obj
-    procedure(obj_assign_obj),            deferred :: obj_assign_obj
-    generic :: operator(*)    => real_times_obj
-    generic :: operator(+)    => obj_plus_obj
-    generic :: assignment(=)  => obj_assign_obj
-  end type
-  abstract interface
-    function process_p (obj)
-      import base_pde_object
-      class(base_pde_object), intent(in)  :: obj
-      class(base_pde_object), allocatable :: process_p
-    end function process_p
-  end interface
-  abstract interface
-    function source_p (obj, time)
-      import base_pde_object
-      class(base_pde_object), intent(in)  :: obj
-      real, intent(in)                    :: time
-      class(base_pde_object), allocatable :: source_p
-    end function source_p
-  end interface
-  abstract interface
-    function process (obj)
-      import base_pde_object
-      class(base_pde_object), intent(in)  :: obj
-      class(base_pde_object), allocatable :: process
-    end function process
-  end interface
-  abstract interface
-    function source (obj, time)
-      import base_pde_object
-      class(base_pde_object), intent(in)  :: obj
-      real, intent(in)                    :: time
-      class(base_pde_object), allocatable :: source
-    end function source
-  end interface
-  abstract interface
-    function real_times_obj (factor, obj) result(newobj)
-      import base_pde_object
-      real, intent(in)                    :: factor
-      class(base_pde_object), intent(in)  :: obj
-      class(base_pde_object), allocatable :: newobj
-    end function real_times_obj
-  end interface
-  abstract interface
-    function obj_plus_obj (obj1, obj2) result(newobj)
-      import base_pde_object
-      class(base_pde_object), intent(in)  :: obj1
-      class(base_pde_object), intent(in)  :: obj2
-      class(base_pde_object), allocatable :: newobj
-    end function obj_plus_obj
-  end interface
-  abstract interface
-    subroutine obj_assign_obj (obj1, obj2)
-      import base_pde_object
-      class(base_pde_object), intent(inout)  :: obj1
-      class(base_pde_object), intent(in)     :: obj2
-    end subroutine obj_assign_obj
-  end interface
-contains
-! print --
-!     Print the concentration field
-  subroutine print (obj)
-    class(base_pde_object) :: obj
-    ! Dummy
-  end subroutine print
-! initialise --
-!     Initialise the concentration field using a specific function
-  subroutine initialise (obj, funcxy)
-    class(base_pde_object) :: obj
-    interface
-      real function funcxy (coords)
-        real, dimension(:), intent(in) :: coords
-      end function funcxy
-    end interface
-    ! Dummy
-  end subroutine initialise
-! nabla2 --
-!     Determine the divergence
-  function nabla2 (obj)
-    class(base_pde_object), intent(in)  :: obj
-    class(base_pde_object), allocatable :: nabla2
-    ! Dummy
-  end function nabla2
-end module base_pde_objects
-! cartesian_2d_objects --
-!     PDE object on a 2D cartesian grid
-!
-module cartesian_2d_objects
-  use base_pde_objects
-  implicit none
-  type, extends(base_pde_object) :: cartesian_2d_object
-    real, dimension(:,:), allocatable :: c
-    real                              :: dx
-    real                              :: dy
-  contains
-    procedure            :: process       => process_cart2d
-    procedure            :: source         => source_cart2d
-    procedure            :: initialise     => initialise_cart2d
-    procedure            :: nabla2         => nabla2_cart2d
-    procedure            :: print          => print_cart2d
-    procedure, pass(obj) :: real_times_obj => real_times_cart2d
-    procedure            :: obj_plus_obj   => obj_plus_cart2d
-    procedure            :: obj_assign_obj => obj_assign_cart2d
-  end type cartesian_2d_object
-  interface grid_definition
-    module procedure grid_definition_cart2d
-  end interface
-contains
-  function process_cart2d (obj)
-    class(cartesian_2d_object), intent(in)  :: obj
-    class(base_pde_object), allocatable :: process_cart2d
-    allocate (process_cart2d,source = obj)
-    select type (process_cart2d)
-      type is (cartesian_2d_object)
-        process_cart2d%c = -sign (obj%c, 1.0)*obj%c** 4
-      class default
-        call abort
-    end select
-  end function process_cart2d
-  function process_cart2d_p (obj)
-    class(base_pde_object), intent(in)  :: obj
-    class(base_pde_object), allocatable :: process_cart2d_p
-    allocate (process_cart2d_p,source = obj)
-    select type (process_cart2d_p)
-      type is (cartesian_2d_object)
-        select type (obj)
-          type is (cartesian_2d_object)
-            process_cart2d_p%c = -sign (obj%c, 1.0)*obj%c** 4
-        end select
-      class default
-        call abort
-    end select
-  end function process_cart2d_p
-  function source_cart2d (obj, time)
-    class(cartesian_2d_object), intent(in)  :: obj
-    real, intent(in)                    :: time
-    class(base_pde_object), allocatable :: source_cart2d
-    integer :: m, n
-    m = size (obj%c, 1)
-    n = size (obj%c, 2)
-    allocate (source_cart2d, source = obj)
-    select type (source_cart2d)
-      type is (cartesian_2d_object)
-        if (allocated (source_cart2d%c)) deallocate (source_cart2d%c)
-        allocate (source_cart2d%c(m, n))
-        source_cart2d%c = 0.0
-        if (time .lt. 5.0) source_cart2d%c(m/2, n/2) = 0.1
-      class default
-        call abort
-    end select
-  end function source_cart2d
-
-  function source_cart2d_p (obj, time)
-    class(base_pde_object), intent(in)  :: obj
-    real, intent(in)                    :: time
-    class(base_pde_object), allocatable :: source_cart2d_p
-    integer :: m, n
-    select type (obj)
-      type is (cartesian_2d_object)
-        m = size (obj%c, 1)
-        n = size (obj%c, 2)
-      class default
-       call abort
-    end select
-    allocate (source_cart2d_p,source = obj)
-    select type (source_cart2d_p)
-      type is (cartesian_2d_object)
-        if (allocated (source_cart2d_p%c)) deallocate (source_cart2d_p%c)
-        allocate (source_cart2d_p%c(m,n))
-        source_cart2d_p%c = 0.0
-        if (time .lt. 5.0) source_cart2d_p%c(m/2, n/2) = 0.1
-      class default
-        call abort
-    end select
-  end function source_cart2d_p
-
-! grid_definition --
-!     Initialises the grid
-!
-  subroutine grid_definition_cart2d (obj, sizes, dims)
-    class(base_pde_object), allocatable :: obj
-    real, dimension(:)                  :: sizes
-    integer, dimension(:)               :: dims
-    allocate( cartesian_2d_object :: obj )
-    select type (obj)
-      type is (cartesian_2d_object)
-        allocate (obj%c(dims(1), dims(2)))
-        obj%c  = 0.0
-        obj%dx = sizes(1)/dims(1)
-        obj%dy = sizes(2)/dims(2)
-      class default
-        call abort
-    end select
-  end subroutine grid_definition_cart2d
-! print_cart2d --
-!     Print the concentration field to the screen
-!
-  subroutine print_cart2d (obj)
-    class(cartesian_2d_object) :: obj
-    character(len=20)          :: format
-    write( format, '(a,i0,a)' ) '(', size(obj%c,1), 'f6.3)'
-    write( *, format ) obj%c
-  end subroutine print_cart2d
-! initialise_cart2d --
-!     Initialise the concentration field using a specific function
-!
-  subroutine initialise_cart2d (obj, funcxy)
-    class(cartesian_2d_object) :: obj
-    interface
-      real function funcxy (coords)
-        real, dimension(:), intent(in) :: coords
-      end function funcxy
-    end interface
-    integer                    :: i, j
-    real, dimension(2)         :: x
-    obj%c = 0.0
-    do j = 2,size (obj%c, 2)-1
-      x(2) = obj%dy * (j-1)
-      do i = 2,size (obj%c, 1)-1
-        x(1) = obj%dx * (i-1)
-        obj%c(i,j) = funcxy (x)
-      enddo
-    enddo
-  end subroutine initialise_cart2d
-! nabla2_cart2d
-!     Determine the divergence
-  function nabla2_cart2d (obj)
-    class(cartesian_2d_object), intent(in)  :: obj
-    class(base_pde_object), allocatable     :: nabla2_cart2d
-    integer                                 :: m, n
-    real                                    :: dx, dy
-    m = size (obj%c, 1)
-    n = size (obj%c, 2)
-    dx = obj%dx
-    dy = obj%dy
-    allocate (cartesian_2d_object :: nabla2_cart2d)
-    select type (nabla2_cart2d)
-      type is (cartesian_2d_object)
-        allocate (nabla2_cart2d%c(m,n))
-        nabla2_cart2d%c = 0.0
-        nabla2_cart2d%c(2:m-1,2:n-1) = &
-          -(2.0 * obj%c(2:m-1,2:n-1) - obj%c(1:m-2,2:n-1) - obj%c(3:m,2:n-1)) / dx**2 &
-          -(2.0 * obj%c(2:m-1,2:n-1) - obj%c(2:m-1,1:n-2) - obj%c(2:m-1,3:n)) / dy**2
-      class default
-        call abort
-    end select
-  end function nabla2_cart2d
-  function real_times_cart2d (factor, obj) result(newobj)
-    real, intent(in)                        :: factor
-    class(cartesian_2d_object), intent(in)  :: obj
-    class(base_pde_object), allocatable     :: newobj
-    integer                                 :: m, n
-    m = size (obj%c, 1)
-    n = size (obj%c, 2)
-    allocate (cartesian_2d_object :: newobj)
-    select type (newobj)
-      type is (cartesian_2d_object)
-        allocate (newobj%c(m,n))
-        newobj%c = factor * obj%c
-      class default
-        call abort
-    end select
-  end function real_times_cart2d
-  function obj_plus_cart2d (obj1, obj2) result( newobj )
-    class(cartesian_2d_object), intent(in)  :: obj1
-    class(base_pde_object), intent(in)      :: obj2
-    class(base_pde_object), allocatable     :: newobj
-    integer                                 :: m, n
-    m = size (obj1%c, 1)
-    n = size (obj1%c, 2)
-    allocate (cartesian_2d_object :: newobj)
-    select type (newobj)
-      type is (cartesian_2d_object)
-        allocate (newobj%c(m,n))
-          select type (obj2)
-            type is (cartesian_2d_object)
-              newobj%c = obj1%c + obj2%c
-            class default
-              call abort
-          end select
-      class default
-        call abort
-    end select
-  end function obj_plus_cart2d
-  subroutine obj_assign_cart2d (obj1, obj2)
-    class(cartesian_2d_object), intent(inout) :: obj1
-    class(base_pde_object), intent(in)        :: obj2
-    select type (obj2)
-      type is (cartesian_2d_object)
-        obj1%c = obj2%c
-      class default
-        call abort
-    end select
-  end subroutine obj_assign_cart2d
-end module cartesian_2d_objects
-! define_pde_objects --
-!     Module to bring all the PDE object types together
-!
-module define_pde_objects
-  use base_pde_objects
-  use cartesian_2d_objects
-  implicit none
-  interface grid_definition
-    module procedure grid_definition_general
-  end interface
-contains
-  subroutine grid_definition_general (obj, type, sizes, dims)
-    class(base_pde_object), allocatable :: obj
-    character(len=*)                    :: type
-    real, dimension(:)                  :: sizes
-    integer, dimension(:)               :: dims
-    select case (type)
-      case ("cartesian 2d")
-        call grid_definition (obj, sizes, dims)
-      case default
-        write(*,*) 'Unknown grid type: ', trim (type)
-        stop
-    end select
-  end subroutine grid_definition_general
-end module define_pde_objects
-! pde_specific --
-!     Module holding the routines specific to the PDE that
-!     we are solving
-!
-module pde_specific
-  implicit none
-contains
-  real function patch (coords)
-    real, dimension(:), intent(in) :: coords
-    if (sum ((coords-[50.0,50.0])**2) < 40.0) then
-      patch = 1.0
-    else
-      patch = 0.0
-    endif
-  end function patch
-end module pde_specific
-! test_pde_solver --
-!     Small test program to demonstrate the usage
-!
-program test_pde_solver
-  use define_pde_objects
-  use pde_specific
-  implicit none
-  class(base_pde_object), allocatable :: solution, deriv
-  integer                             :: i
-  real                                :: time, dtime, diff, chksum(2)
-
-  call simulation1     ! Use proc pointers for source and process define_pde_objects
-  select type (solution)
-    type is (cartesian_2d_object)
-      deallocate (solution%c)
-  end select
-  select type (deriv)
-    type is (cartesian_2d_object)
-      deallocate (deriv%c)
-  end select
-  deallocate (solution, deriv)
-
-  call simulation2     ! Use typebound procedures for source and process
-  if (chksum(1) .ne. chksum(2)) call abort
-  if ((chksum(1) - 0.881868720)**2 > 1e-4) call abort
-contains
-  subroutine simulation1
-!
-! Create the grid
-!
-    call grid_definition (solution, "cartesian 2d", [100.0, 100.0], [16, 16])
-    call grid_definition (deriv,    "cartesian 2d", [100.0, 100.0], [16, 16])
-!
-! Initialise the concentration field
-!
-    call solution%initialise (patch)
-!
-! Set the procedure pointers
-!
-    solution%source_p => source_cart2d_p
-    solution%process_p => process_cart2d_p
-!
-! Perform the integration - explicit method
-!
-    time  = 0.0
-    dtime = 0.1
-    diff =  5.0e-3
-
-! Give the diffusion coefficient correct dimensions.
-    select type (solution)
-      type is (cartesian_2d_object)
-        diff  = diff * solution%dx * solution%dy / dtime
-    end select
-
-!     write(*,*) 'Time: ', time, diff
-!     call solution%print
-    do i = 1,100
-      deriv    =  solution%nabla2 ()
-      solution = solution + diff * dtime * deriv + solution%source_p (time) + solution%process_p ()
-!         if ( mod(i, 25) == 0 ) then
-!             write(*,*)'Time: ', time
-!             call solution%print
-!         endif
-    time = time + dtime
-    enddo
-!    write(*,*) 'End result 1: '
-!    call solution%print
-    select type (solution)
-      type is (cartesian_2d_object)
-        chksum(1) = sum (solution%c)
-    end select
-  end subroutine
-  subroutine simulation2
-!
-! Create the grid
-!
-    call grid_definition (solution, "cartesian 2d", [100.0, 100.0], [16, 16])
-    call grid_definition (deriv,    "cartesian 2d", [100.0, 100.0], [16, 16])
-!
-! Initialise the concentration field
-!
-    call solution%initialise (patch)
-!
-! Set the procedure pointers
-!
-    solution%source_p => source_cart2d_p
-    solution%process_p => process_cart2d_p
-!
-! Perform the integration - explicit method
-!
-    time  = 0.0
-    dtime = 0.1
-    diff =  5.0e-3
-
-! Give the diffusion coefficient correct dimensions.
-    select type (solution)
-      type is (cartesian_2d_object)
-        diff  = diff * solution%dx * solution%dy / dtime
-    end select
-
-!     write(*,*) 'Time: ', time, diff
-!     call solution%print
-    do i = 1,100
-      deriv    =  solution%nabla2 ()
-      solution = solution + diff * dtime * deriv + solution%source (time) + solution%process ()
-!         if ( mod(i, 25) == 0 ) then
-!             write(*,*)'Time: ', time
-!             call solution%print
-!         endif
-      time = time + dtime
-    enddo
-!    write(*,*) 'End result 2: '
-!    call solution%print
-    select type (solution)
-      type is (cartesian_2d_object)
-        chksum(2) = sum (solution%c)
-    end select
-  end subroutine
-end program test_pde_solver
